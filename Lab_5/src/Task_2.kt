/**
 * Задание 2
 *
 * Вычисление приближённого значения интеграла:
 *      ∫₋₁¹ (2^x / sqrt(1 - x²)) dx
 * с использованием двух квадратурных формул при том же количестве узлов:
 * 1. Квадратурная формула НАСТ – вычисляется путём получения весов для равномерно распределённых узлов
 *    (для каждого узла решается система линейных уравнений для выполнения точности для полиномов степени до n-1).
 * 2. Формула средних прямоугольников  – интегрирование по подинтервалам с использованием
 *    середины интервала.
 *
 * Для демонстрации работы выбираются различные количества узлов, а также проводится оценка погрешности
 * (аналитическая оценка ошибки для равномерных квадратурных формул зависит от производных функции).
 */
import kotlin.math.abs
import kotlin.math.pow
import kotlin.math.sqrt
import kotlin.system.exitProcess

/** Функция-объект для второго интеграла: f(x) = 2^x / sqrt(1 - x^2) */
val f2: (Double) -> Double = { x ->
    // Обработка особой точки: при x близких к ±1 знаменатель стремится к 0.
    if (abs(x) == 1.0) 0.0 else 2.0.pow(x) / sqrt(1 - x*x)
}

/**
 * Вычисление весов квадратурной формулы НАСТ (закрытая формула Ньютона–Котеса для n узлов).
 *
 * Решается система линейных уравнений:
 *   Для k = 0,1,..., n-1 должно выполняться:
 *      Σ (wᵢ * (xᵢ)^k) = Mₖ,
 * где Mₖ = ∫ₐᵇ x^k dx = (b^(k+1) - a^(k+1))/(k+1)
 *
 * @param n Число узлов (должно быть >= 2)
 * @param a Левый предел интегрирования
 * @param b Правый предел интегрирования
 * @return Массив весов для каждого узла
 */
fun computeNewtonCotesWeights(n: Int, a: Double, b: Double): DoubleArray {
    if(n < 2) {
        println("Количество узлов должно быть не меньше 2")
        exitProcess(1)
    }
    val nodes = DoubleArray(n) { i -> a + i * (b - a) / (n - 1) }
    // Составляем матрицу Вандермонда V[i][k] = (xᵢ)^k, i, k = 0,..., n-1
    val V = Array(n) { DoubleArray(n) }
    for (i in 0 until n) {
        var xi = 1.0
        for (k in 0 until n) {
            V[i][k] = xi
            xi *= nodes[i]
        }
    }
    // Правая часть: моменты Mₖ = (b^(k+1) - a^(k+1))/(k+1)
    val M = DoubleArray(n) { k -> (b.pow(k+1) - a.pow(k+1)) / (k+1) }

    // Решаем систему V * w = M методом Гаусса (не оптимально, но для малых n подходит)
    val w = gaussianElimination(V, M)
    return w
}

/**
 * Решение системы линейных уравнений Ax = b методом Гаусса.
 *
 * @param A Матрица коэффициентов (изменяется в процессе)
 * @param b Правая часть (изменяется в процессе)
 * @return Решение системы в виде массива x
 */
fun gaussianElimination(A: Array<DoubleArray>, b: DoubleArray): DoubleArray {
    val n = b.size
    // Прямой ход
    for (i in 0 until n) {
        // Поиск опорного элемента
        var maxRow = i
        for (j in i+1 until n) {
            if (abs(A[j][i]) > abs(A[maxRow][i])) {
                maxRow = j
            }
        }
        // Меняем строки местами
        A[i] = A[maxRow].also { A[maxRow] = A[i] }
        b[i] = b[maxRow].also { b[maxRow] = b[i] }

        // Если опорный элемент равен нулю, система вырождена
        if (abs(A[i][i]) < 1e-12) {
            throw IllegalArgumentException("Система вырождена")
        }
        // Нормализуем строку и вычитаем
        for (j in i+1 until n) {
            val factor = A[j][i] / A[i][i]
            for (k in i until n) {
                A[j][k] -= factor * A[i][k]
            }
            b[j] -= factor * b[i]
        }
    }
    // Обратный ход
    val x = DoubleArray(n)
    for (i in n-1 downTo 0) {
        var sum = 0.0
        for (j in i+1 until n) {
            sum += A[i][j] * x[j]
        }
        x[i] = (b[i] - sum) / A[i][i]
    }
    return x
}

/**
 * Вычисление интеграла по квадратурной формуле НАСТ.
 *
 * @param f Функция под интегралом
 * @param a Левый предел интегрирования
 * @param b Правый предел интегрирования
 * @param n Число узлов (используется при вычислении весов и узлов)
 * @return Приближённое значение интеграла
 */
fun newtonCotesNAST(f: (Double) -> Double, a: Double, b: Double, n: Int): Double {
    // Вычисляем узлы (одинаково распределённые)
    val nodes = DoubleArray(n) { i -> a + i * (b - a) / (n - 1) }
    // Вычисляем веса
    val weights = computeNewtonCotesWeights(n, a, b)
    // Суммируем вклад каждого узла
    var sum = 0.0
    for (i in 0 until n) {
        sum += weights[i] * f(nodes[i])
    }
    return sum
}

/**
 * Вычисление интеграла по формуле средних прямоугольников (midpoint rule).
 *
 * @param f Функция под интегралом
 * @param a Левый предел интегрирования
 * @param b Правый предел интегрирования
 * @param n Число узлов => число подынтервалов будет n-1
 * @return Приближённое значение интеграла
 */
fun midpointRule(f: (Double) -> Double, a: Double, b: Double, n: Int): Double {
    val h = (b - a) / (n - 1)
    var sum = 0.0
    // Для каждого подынтервала берем середину
    for (i in 0 until n - 1) {
        val xMid = a + (i + 0.5) * h
        sum += f(xMid)
    }
    return sum * h
}

/**
 * Главная функция для запуска задания 2.
 *
 * Выполняется расчёт интеграла для различных чисел узлов для обеих формул.
 */
fun main() {
    // Пределы интегрирования
    val a = -1.0
    val b = 1.0

    println("Задание 2: Вычисление интеграла от -1 до 1 для функции f(x) = 2^x / sqrt(1 - x^2)")

    // Выбираем набор значений числа узлов
    val nodesList = listOf(3, 5, 9, 17)
    for (n in nodesList) {
        println("\nКоличество узлов: $n")
        try {
            val resultNAST = newtonCotesNAST(f2, a, b, n)
            val resultMidpoint = midpointRule(f2, a, b, n)
            println("  КФ НАСТ (Newton–Cotes): $resultNAST")
            println("  Формула средних прямоугольников: $resultMidpoint")
            // Аналитическая оценка погрешности может быть выведена, если известны производные функции,
            // здесь в качестве примера оцениваем разность между методами.
            println("  Разность между оценками: ${abs(resultNAST - resultMidpoint)}")
        } catch (e: Exception) {
            println("  Ошибка при вычислении для n = $n: ${e.message}")
        }
    }

    // Вывод дополнительных комментариев.
    println("\nКомментарий:")
    println("При увеличении числа узлов оба метода должны сходиться к одному значению,")
    println("что позволяет сделать вывод о сравнительной эффективности КФ НАСТ по сравнению с формулой средних прямоугольников.")
    println("В аналитической оценке погрешности учитываются высокие производные интегрируемой функции,")
    println("а также константы, зависящие от равномерного разбиения интервала интегрирования.")
}
